%{
	#include "contracts.hpp"
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();
	int yyerror(char * message);
	extern int yylineno;
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN LBRACE RBRACE ID NUM STRING

%nonassoc RPAREN /* solving dangling-else problem */
%nonassoc ELSE /* solving dangling-else problem */

%right ASSIGN
%left OR
%left AND
%left RELOP
%left BINOP
%right NOT

%%
Test : Statement {$$.type = $1.type;}
    ;

Program	: Funcs
	;

Funcs : FuncDecl Funcs | /*epsilon*/
	;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE
    ;

RetType : Type | VOID
    ;

Formals : FormalsList | /*epsilon*/
    ;

FormalsList : FormalDecl | FormalDecl COMMA FormalsList
    ;

FormalDecl : Type ID
    ;

Statements : Statement | Statements Statement
    ;

Statement : LBRACE Statements RBRACE |
            Type ID SC |
            Type ID ASSIGN Exp SC |
            ID ASSIGN Exp SC {$$.type = $3.type;} |
            Call SC |
            RETURN SC |
            RETURN Exp SC {$$.type = $1.type;} |
            IF LPAREN Exp RPAREN Statement |
            IF LPAREN Exp RPAREN Statement ELSE Statement |
            WHILE LPAREN Exp RPAREN Statement |
            BREAK SC |
            SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE SC
    ;

CaseList : CaseStat CaseList | CaseStat
    ;

CaseStat : CASE NUM COLON Statement BREAK SC |
           CASE NUM B COLON Statement BREAK SC
    ;

Call : ID LPAREN ExpList RPAREN | ID LPAREN RPAREN
    ;

ExpList : Exp {$$.type = $1.type;} |
          Exp COMMA ExpList
    ;

Type : INT | BYTE | BOOL
    ;

Exp : LPAREN Exp RPAREN {$$.type = $2.type;} |
      Exp BINOP Exp |
      ID {$$.type = $1.type;} |
      Call {$$.type = $1.type;} |
      NUM {$$.type = $1.type;} |
      NUM B {$$.type = $1.type;} |
      STRING {$$.type = $1.type;} |
      TRUE {$$.type = $1.type;} |
      FALSE {$$.type = $1.type;} |
      NOT Exp {$$.type = $1.type;} |
      Exp AND Exp
      {
            if($1.type != _BOOL || $1.type != $2.type)
                output::errorMismatch(yylineno);
            {$$.type = $1.type;}
      } |
      Exp OR Exp {$$.type = $1.type;} |
      Exp RELOP Exp {$$.type = $1.type;}
    ;
%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}