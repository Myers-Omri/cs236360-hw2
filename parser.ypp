%{
	#include "Contracts.hpp"
	#include "Utils.hpp"
	#include "output.hpp"
	#include "SymbolTable.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();
	int yyerror(char * message);
	extern int yylineno;
	SymbolTable* symbolTable;
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN LBRACE RBRACE ID NUM STRING

%nonassoc RPAREN /* solving dangling-else problem */
%nonassoc ELSE /* solving dangling-else problem */

%right ASSIGN
%left OR
%left AND
%left RELOP
%left BINOP
%right NOT

%%

Program	: Funcs
          {
            symbolTable->EndProg();
          }
	;

Funcs : FuncDecl Funcs
        {

        } | /*epsilon*/
	;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE
           {
                symbolTable->AddFunc($2.varName,$1.type);
           }
    ;

RetType : Type | VOID
    ;

Formals : FormalsList | /*epsilon*/
    ;

FormalsList : FormalDecl | FormalDecl COMMA FormalsList
    ;

FormalDecl : Type ID
    ;

Statements : Statement | Statements Statement {$$.type = $2.type;}
    ;

Statement : LBRACE Statements RBRACE |
            Type ID SC |
            Type ID ASSIGN Exp SC |
            ID ASSIGN Exp SC
            {
                if($1.type == $3.type || ($1.type == _INT && $3.type == _BYTE))
                    $$ = $1 = $3;
            } |
            Call SC |
            RETURN SC |
            RETURN Exp SC {$$.type = $1.type;} |
            IF LPAREN Exp RPAREN Statement |
            IF LPAREN Exp RPAREN Statement ELSE Statement |
            WHILE LPAREN Exp RPAREN Statement |
            BREAK SC |
            SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE SC
    ;

CaseList : CaseStat CaseList | CaseStat
    ;

CaseStat : CASE NUM COLON Statement BREAK SC |
           CASE NUM B COLON Statement BREAK SC
    ;

Call : ID LPAREN ExpList RPAREN {$$.type = $1.type;} | ID LPAREN RPAREN {$$.type = $1.type;}
    ;

ExpList : Exp {$$.type = $1.type;} |
          Exp COMMA ExpList
    ;

Type : INT {$$.type = _INT;} | BYTE {$$.type = _BYTE;} | BOOL {$$.type = _BOOL;}
    ;

Exp : LPAREN Exp RPAREN {$$.type = $2.type;} |
      ID {$$.type = $1.type;} |
      Call {$$.type = $1.type;} |
      NUM {$$.type = $1._INT; $.numVal = $1.numVal;} |
      NUM B {$$.type = $1._BYTE; $$.numVal = $1.numVal;} |
      STRING {$$.type = $1.type; $$.stringVal = $1.stringVal;} |
      TRUE {$$.type = $1.type; $$.boolVal = $1.boolVal;} |
      FALSE {$$.type = $1.type; $$.boolVal = $1.boolVal;} |
      NOT Exp
      {
            if(!isBoolean($1)
            {
                output::errorMisMatch(yylineno);
                exit(0);
            }
            $$.type = $1.type;
            $$.boolVal = !$1.boolVal;
      } |
      Exp AND Exp
      {
            if($1.type != _BOOL || $1.type != $3.type)
            {
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = $1.type;
            $$.boolVal = $1.boolVal && $3.boolVal;
      } |
      Exp OR Exp {$$.type = $1.type;}
      {
            if(!isBoolean($1) || !areEqualTypes($1,$3))
            {
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = $1.type;
            $$.boolVal = $1.boolVal || $3.boolVal;
      } |
      Exp RELOP Exp
      {
            if(!isNumeric($1) || !areEqualTypes($1,$3))
            {
                output::errorMisMatch(yylineno);
                exit(0);
            }
            $$.type = _BOOL;
      } |
      Exp BINOP Exp
      {
            if(!isNumeric($1) || !isNumeric($3))
            {
                output::errorMisMatch(yylineno);
                exit(0);
            }
            $$.type = ($1.type == _BYTE) ? $3.type : $1.type;
      }
    ;
%%

int main()
{
	symbolTable = new SymbolTable();
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}